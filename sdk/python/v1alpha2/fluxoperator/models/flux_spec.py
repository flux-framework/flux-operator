# coding: utf-8

"""
    fluxoperator

    Python SDK for Flux-Operator

    The version of the OpenAPI document: v1alpha2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from fluxoperator.models.bursting import Bursting
from fluxoperator.models.flux_container import FluxContainer
from fluxoperator.models.flux_scheduler import FluxScheduler
from typing import Optional, Set
from typing_extensions import Self

class FluxSpec(BaseModel):
    """
    FluxSpec
    """ # noqa: E501
    arch: Optional[StrictStr] = Field(default=None, description="Change the arch string - determines the binaries that are downloaded to run the entrypoint")
    broker_config: Optional[StrictStr] = Field(default='', description="Optionally provide a manually created broker config this is intended for bursting to remote clusters", alias="brokerConfig")
    bursting: Optional[Bursting] = None
    complete_workers: Optional[StrictBool] = Field(default=False, description="Complete workers when they fail This is ideal if you don't want them to restart", alias="completeWorkers")
    connect_timeout: Optional[StrictStr] = Field(default='5s', description="Single user executable to provide to flux start", alias="connectTimeout")
    container: Optional[FluxContainer] = None
    curve_cert: Optional[StrictStr] = Field(default='', description="Optionally provide an already existing curve certificate This is not recommended in favor of providing the secret name as curveCertSecret, below", alias="curveCert")
    hostlist: Optional[StrictStr] = Field(default='', description="Provide a custom hostlist - useful if hostNetwork is set to true")
    log_level: Optional[StrictInt] = Field(default=6, description="Log level to use for flux logging (only in non TestMode)", alias="logLevel")
    main_host: Optional[StrictStr] = Field(default='', description="If a different primary host is indicated", alias="mainHost")
    minimal_service: Optional[StrictBool] = Field(default=False, description="Only expose the broker service (to reduce load on DNS)", alias="minimalService")
    munge_secret: Optional[StrictStr] = Field(default='', description="Expect a secret (named according to this string) for a munge key. This is intended for bursting. Assumed to be at /etc/munge/munge.key This is binary data.", alias="mungeSecret")
    no_wait_socket: Optional[StrictBool] = Field(default=False, description="Do not wait for the socket", alias="noWaitSocket")
    option_flags: Optional[StrictStr] = Field(default='', description="Flux option flags, usually provided with -o optional - if needed, default option flags for the server These can also be set in the user interface to override here. This is only valid for a FluxRunner \"runFlux\" true", alias="optionFlags")
    scheduler: Optional[FluxScheduler] = None
    submit_command: Optional[StrictStr] = Field(default=None, description="Modify flux submit to be something else", alias="submitCommand")
    wrap: Optional[StrictStr] = Field(default=None, description="Commands for flux start --wrap")
    __properties: ClassVar[List[str]] = ["arch", "brokerConfig", "bursting", "completeWorkers", "connectTimeout", "container", "curveCert", "hostlist", "logLevel", "mainHost", "minimalService", "mungeSecret", "noWaitSocket", "optionFlags", "scheduler", "submitCommand", "wrap"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FluxSpec from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of bursting
        if self.bursting:
            _dict['bursting'] = self.bursting.to_dict()
        # override the default output from pydantic by calling `to_dict()` of container
        if self.container:
            _dict['container'] = self.container.to_dict()
        # override the default output from pydantic by calling `to_dict()` of scheduler
        if self.scheduler:
            _dict['scheduler'] = self.scheduler.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FluxSpec from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "arch": obj.get("arch"),
            "brokerConfig": obj.get("brokerConfig") if obj.get("brokerConfig") is not None else '',
            "bursting": Bursting.from_dict(obj["bursting"]) if obj.get("bursting") is not None else None,
            "completeWorkers": obj.get("completeWorkers") if obj.get("completeWorkers") is not None else False,
            "connectTimeout": obj.get("connectTimeout") if obj.get("connectTimeout") is not None else '5s',
            "container": FluxContainer.from_dict(obj["container"]) if obj.get("container") is not None else None,
            "curveCert": obj.get("curveCert") if obj.get("curveCert") is not None else '',
            "hostlist": obj.get("hostlist") if obj.get("hostlist") is not None else '',
            "logLevel": obj.get("logLevel") if obj.get("logLevel") is not None else 6,
            "mainHost": obj.get("mainHost") if obj.get("mainHost") is not None else '',
            "minimalService": obj.get("minimalService") if obj.get("minimalService") is not None else False,
            "mungeSecret": obj.get("mungeSecret") if obj.get("mungeSecret") is not None else '',
            "noWaitSocket": obj.get("noWaitSocket") if obj.get("noWaitSocket") is not None else False,
            "optionFlags": obj.get("optionFlags") if obj.get("optionFlags") is not None else '',
            "scheduler": FluxScheduler.from_dict(obj["scheduler"]) if obj.get("scheduler") is not None else None,
            "submitCommand": obj.get("submitCommand"),
            "wrap": obj.get("wrap")
        })
        return _obj



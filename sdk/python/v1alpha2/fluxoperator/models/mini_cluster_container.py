# coding: utf-8

"""
    fluxoperator

    Python SDK for Flux-Operator

    The version of the OpenAPI document: v1alpha2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from fluxoperator.models.commands import Commands
from fluxoperator.models.container_resources import ContainerResources
from fluxoperator.models.container_volume import ContainerVolume
from fluxoperator.models.life_cycle import LifeCycle
from fluxoperator.models.secret import Secret
from fluxoperator.models.security_context import SecurityContext
from typing import Optional, Set
from typing_extensions import Self

class MiniClusterContainer(BaseModel):
    """
    MiniClusterContainer
    """ # noqa: E501
    batch: Optional[StrictBool] = Field(default=False, description="Indicate that the command is a batch job that will be written to a file to submit")
    batch_raw: Optional[StrictBool] = Field(default=False, description="Don't wrap batch commands in flux submit (provide custom logic myself)", alias="batchRaw")
    command: Optional[StrictStr] = Field(default='', description="Single user executable to provide to flux start")
    commands: Optional[Commands] = None
    environment: Optional[Dict[str, StrictStr]] = Field(default=None, description="Key/value pairs for the environment")
    image: Optional[StrictStr] = Field(default='ghcr.io/rse-ops/accounting:app-latest', description="Container image must contain flux and flux-sched install")
    image_pull_secret: Optional[StrictStr] = Field(default='', description="Allow the user to pull authenticated images By default no secret is selected. Setting this with the name of an already existing imagePullSecret will specify that secret in the pod spec.", alias="imagePullSecret")
    launcher: Optional[StrictBool] = Field(default=False, description="Indicate that the command is a launcher that will ask for its own jobs (and provided directly to flux start)")
    life_cycle: Optional[LifeCycle] = Field(default=None, alias="lifeCycle")
    logs: Optional[StrictStr] = Field(default='', description="Log output directory")
    name: Optional[StrictStr] = Field(default='', description="Container name is only required for non flux runners")
    no_wrap_entrypoint: Optional[StrictBool] = Field(default=False, description="Do not wrap the entrypoint to wait for flux, add to path, etc?", alias="noWrapEntrypoint")
    ports: Optional[List[StrictInt]] = Field(default=None, description="Ports to be exposed to other containers in the cluster We take a single list of integers and map to the same")
    pull_always: Optional[StrictBool] = Field(default=False, description="Allow the user to dictate pulling By default we pull if not present. Setting this to true will indicate to pull always", alias="pullAlways")
    resources: Optional[ContainerResources] = None
    run_flux: Optional[StrictBool] = Field(default=False, description="Application container intended to run flux (broker)", alias="runFlux")
    secrets: Optional[Dict[str, Secret]] = Field(default=None, description="Secrets that will be added to the environment The user is expected to create their own secrets for the operator to find")
    security_context: Optional[SecurityContext] = Field(default=None, alias="securityContext")
    volumes: Optional[Dict[str, ContainerVolume]] = Field(default=None, description="Existing volumes that can be mounted")
    working_dir: Optional[StrictStr] = Field(default='', description="Working directory to run command from", alias="workingDir")
    __properties: ClassVar[List[str]] = ["batch", "batchRaw", "command", "commands", "environment", "image", "imagePullSecret", "launcher", "lifeCycle", "logs", "name", "noWrapEntrypoint", "ports", "pullAlways", "resources", "runFlux", "secrets", "securityContext", "volumes", "workingDir"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MiniClusterContainer from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of commands
        if self.commands:
            _dict['commands'] = self.commands.to_dict()
        # override the default output from pydantic by calling `to_dict()` of life_cycle
        if self.life_cycle:
            _dict['lifeCycle'] = self.life_cycle.to_dict()
        # override the default output from pydantic by calling `to_dict()` of resources
        if self.resources:
            _dict['resources'] = self.resources.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in secrets (dict)
        _field_dict = {}
        if self.secrets:
            for _key in self.secrets:
                if self.secrets[_key]:
                    _field_dict[_key] = self.secrets[_key].to_dict()
            _dict['secrets'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of security_context
        if self.security_context:
            _dict['securityContext'] = self.security_context.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in volumes (dict)
        _field_dict = {}
        if self.volumes:
            for _key in self.volumes:
                if self.volumes[_key]:
                    _field_dict[_key] = self.volumes[_key].to_dict()
            _dict['volumes'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MiniClusterContainer from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "batch": obj.get("batch") if obj.get("batch") is not None else False,
            "batchRaw": obj.get("batchRaw") if obj.get("batchRaw") is not None else False,
            "command": obj.get("command") if obj.get("command") is not None else '',
            "commands": Commands.from_dict(obj["commands"]) if obj.get("commands") is not None else None,
            "environment": obj.get("environment"),
            "image": obj.get("image") if obj.get("image") is not None else 'ghcr.io/rse-ops/accounting:app-latest',
            "imagePullSecret": obj.get("imagePullSecret") if obj.get("imagePullSecret") is not None else '',
            "launcher": obj.get("launcher") if obj.get("launcher") is not None else False,
            "lifeCycle": LifeCycle.from_dict(obj["lifeCycle"]) if obj.get("lifeCycle") is not None else None,
            "logs": obj.get("logs") if obj.get("logs") is not None else '',
            "name": obj.get("name") if obj.get("name") is not None else '',
            "noWrapEntrypoint": obj.get("noWrapEntrypoint") if obj.get("noWrapEntrypoint") is not None else False,
            "ports": obj.get("ports"),
            "pullAlways": obj.get("pullAlways") if obj.get("pullAlways") is not None else False,
            "resources": ContainerResources.from_dict(obj["resources"]) if obj.get("resources") is not None else None,
            "runFlux": obj.get("runFlux") if obj.get("runFlux") is not None else False,
            "secrets": dict(
                (_k, Secret.from_dict(_v))
                for _k, _v in obj["secrets"].items()
            )
            if obj.get("secrets") is not None
            else None,
            "securityContext": SecurityContext.from_dict(obj["securityContext"]) if obj.get("securityContext") is not None else None,
            "volumes": dict(
                (_k, ContainerVolume.from_dict(_v))
                for _k, _v in obj["volumes"].items()
            )
            if obj.get("volumes") is not None
            else None,
            "workingDir": obj.get("workingDir") if obj.get("workingDir") is not None else ''
        })
        return _obj



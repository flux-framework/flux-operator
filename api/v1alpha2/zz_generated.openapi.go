//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2022-2023 Lawrence Livermore National Security, LLC
 (c.f. AUTHORS, NOTICE.LLNS, COPYING)

This is part of the Flux resource manager framework.
For details, see https://github.com/flux-framework.

SPDX-License-Identifier: Apache-2.0
*/

// Code generated by openapi-gen. DO NOT EDIT.

// This file was autogenerated by openapi-gen. Do not edit it manually!

package v1alpha2

import (
	common "k8s.io/kube-openapi/pkg/common"
	spec "k8s.io/kube-openapi/pkg/validation/spec"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"./api/v1alpha2/.BurstedCluster":       schema__api_v1alpha2__BurstedCluster(ref),
		"./api/v1alpha2/.Bursting":             schema__api_v1alpha2__Bursting(ref),
		"./api/v1alpha2/.Commands":             schema__api_v1alpha2__Commands(ref),
		"./api/v1alpha2/.ContainerResources":   schema__api_v1alpha2__ContainerResources(ref),
		"./api/v1alpha2/.ContainerVolume":      schema__api_v1alpha2__ContainerVolume(ref),
		"./api/v1alpha2/.FluxBroker":           schema__api_v1alpha2__FluxBroker(ref),
		"./api/v1alpha2/.FluxContainer":        schema__api_v1alpha2__FluxContainer(ref),
		"./api/v1alpha2/.FluxScheduler":        schema__api_v1alpha2__FluxScheduler(ref),
		"./api/v1alpha2/.FluxSpec":             schema__api_v1alpha2__FluxSpec(ref),
		"./api/v1alpha2/.LifeCycle":            schema__api_v1alpha2__LifeCycle(ref),
		"./api/v1alpha2/.LoggingSpec":          schema__api_v1alpha2__LoggingSpec(ref),
		"./api/v1alpha2/.MiniCluster":          schema__api_v1alpha2__MiniCluster(ref),
		"./api/v1alpha2/.MiniClusterArchive":   schema__api_v1alpha2__MiniClusterArchive(ref),
		"./api/v1alpha2/.MiniClusterContainer": schema__api_v1alpha2__MiniClusterContainer(ref),
		"./api/v1alpha2/.MiniClusterList":      schema__api_v1alpha2__MiniClusterList(ref),
		"./api/v1alpha2/.MiniClusterSpec":      schema__api_v1alpha2__MiniClusterSpec(ref),
		"./api/v1alpha2/.MiniClusterStatus":    schema__api_v1alpha2__MiniClusterStatus(ref),
		"./api/v1alpha2/.MiniClusterUser":      schema__api_v1alpha2__MiniClusterUser(ref),
		"./api/v1alpha2/.Network":              schema__api_v1alpha2__Network(ref),
		"./api/v1alpha2/.PodSpec":              schema__api_v1alpha2__PodSpec(ref),
		"./api/v1alpha2/.Secret":               schema__api_v1alpha2__Secret(ref),
		"./api/v1alpha2/.SecurityContext":      schema__api_v1alpha2__SecurityContext(ref),
	}
}

func schema__api_v1alpha2__BurstedCluster(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "The hostnames for the bursted clusters If set, the user is responsible for ensuring uniqueness. The operator will set to burst-N",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"size": {
						SchemaProps: spec.SchemaProps{
							Description: "Size of bursted cluster. Defaults to same size as local minicluster if not set",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema__api_v1alpha2__Bursting(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Bursting Config For simplicity, we internally handle the name of the job (hostnames)",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"leadBroker": {
						SchemaProps: spec.SchemaProps{
							Description: "The lead broker ip address to join to. E.g., if we burst to cluster 2, this is the address to connect to cluster 1 For the first cluster, this should not be defined",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.FluxBroker"),
						},
					},
					"hostlist": {
						SchemaProps: spec.SchemaProps{
							Description: "Hostlist is a custom hostlist for the broker.toml that includes the local plus bursted cluster. This is typically used for bursting to another resource type, where we can predict the hostnames but they don't follow the same convention as the Flux Operator",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"clusters": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "External clusters to burst to. Each external cluster must share the same listing to align ranks",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("./api/v1alpha2/.BurstedCluster"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./api/v1alpha2/.BurstedCluster", "./api/v1alpha2/.FluxBroker"},
	}
}

func schema__api_v1alpha2__Commands(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"prefix": {
						SchemaProps: spec.SchemaProps{
							Description: "Prefix to flux start / submit / broker Typically used for a wrapper command to mount, etc.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"init": {
						SchemaProps: spec.SchemaProps{
							Description: "init command is run before anything",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pre": {
						SchemaProps: spec.SchemaProps{
							Description: "pre command is run after global PreCommand, after asFlux is set (can override)",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"post": {
						SchemaProps: spec.SchemaProps{
							Description: "post command is run in the entrypoint when the broker exits / finishes",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"workerPre": {
						SchemaProps: spec.SchemaProps{
							Description: "A command only for workers to run",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"brokerPre": {
						SchemaProps: spec.SchemaProps{
							Description: "A single command for only the broker to run",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"servicePre": {
						SchemaProps: spec.SchemaProps{
							Description: "A command only for service start.sh tor run",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema__api_v1alpha2__ContainerResources(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerResources include limits and requests",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"limits": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
									},
								},
							},
						},
					},
					"requests": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema__api_v1alpha2__ContainerVolume(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path and claim name are always required if a secret isn't defined",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostPath": {
						SchemaProps: spec.SchemaProps{
							Description: "An existing hostPath to bind to path",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configMapName": {
						SchemaProps: spec.SchemaProps{
							Description: "Config map name if the existing volume is a config map You should also define items if you are using this",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Description: "Items (key and paths) for the config map",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"claimName": {
						SchemaProps: spec.SchemaProps{
							Description: "Claim name if the existing volume is a PVC",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"secretName": {
						SchemaProps: spec.SchemaProps{
							Description: "An existing secret",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"readOnly": {
						SchemaProps: spec.SchemaProps{
							Default: false,
							Type:    []string{"boolean"},
							Format:  "",
						},
					},
				},
			},
		},
	}
}

func schema__api_v1alpha2__FluxBroker(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "A FluxBroker defines a broker for flux",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"address": {
						SchemaProps: spec.SchemaProps{
							Description: "Lead broker address (ip or hostname)",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "We need the name of the lead job to assemble the hostnames",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"size": {
						SchemaProps: spec.SchemaProps{
							Description: "Lead broker size",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Lead broker port - should only be used for external cluster",
							Default:     8050,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"address", "name", "size"},
			},
		},
	}
}

func schema__api_v1alpha2__FluxContainer(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "A FluxContainer is equivalent to a MiniCluster container but has a different default image",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"disable": {
						SchemaProps: spec.SchemaProps{
							Description: "Disable the sidecar container, assuming that the main application container has flux",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Container name is only required for non flux runners",
							Default:     "flux-view",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"workingDir": {
						SchemaProps: spec.SchemaProps{
							Description: "Working directory to run command from",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pythonPath": {
						SchemaProps: spec.SchemaProps{
							Description: "Customize python path for flux",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Resources include limits and requests These must be defined for cpu and memory for the QoS to be Guaranteed",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.ContainerResources"),
						},
					},
					"imagePullSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "Allow the user to pull authenticated images By default no secret is selected. Setting this with the name of an already existing imagePullSecret will specify that secret in the pod spec.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"image": {
						SchemaProps: spec.SchemaProps{
							Default: "ghcr.io/converged-computing/flux-view-rocky:tag-9",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"pullAlways": {
						SchemaProps: spec.SchemaProps{
							Description: "Allow the user to dictate pulling By default we pull if not present. Setting this to true will indicate to pull always",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"mountPath": {
						SchemaProps: spec.SchemaProps{
							Description: "Mount path for flux to be at (will be added to path)",
							Default:     "/mnt/flux",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./api/v1alpha2/.ContainerResources"},
	}
}

func schema__api_v1alpha2__FluxScheduler(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FluxScheduler attributes",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"queuePolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Scheduler queue policy, defaults to \"fcfs\" can also be \"easy\"",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema__api_v1alpha2__FluxSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"container": {
						SchemaProps: spec.SchemaProps{
							Description: "Container base for flux",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.FluxContainer"),
						},
					},
					"submitCommand": {
						SchemaProps: spec.SchemaProps{
							Description: "Modify flux submit to be something else",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"wrap": {
						SchemaProps: spec.SchemaProps{
							Description: "Commands for flux start --wrap",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"connectTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Single user executable to provide to flux start",
							Default:     "5s",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"optionFlags": {
						SchemaProps: spec.SchemaProps{
							Description: "Flux option flags, usually provided with -o optional - if needed, default option flags for the server These can also be set in the user interface to override here. This is only valid for a FluxRunner \"runFlux\" true",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"minimalService": {
						SchemaProps: spec.SchemaProps{
							Description: "Only expose the broker service (to reduce load on DNS)",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"noWaitSocket": {
						SchemaProps: spec.SchemaProps{
							Description: "Do not wait for the socket",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"logLevel": {
						SchemaProps: spec.SchemaProps{
							Description: "Log level to use for flux logging (only in non TestMode)",
							Default:     6,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"curveCert": {
						SchemaProps: spec.SchemaProps{
							Description: "Optionally provide an already existing curve certificate This is not recommended in favor of providing the secret name as curveCertSecret, below",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scheduler": {
						SchemaProps: spec.SchemaProps{
							Description: "Custom attributes for the fluxion scheduler",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.FluxScheduler"),
						},
					},
					"mungeSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "Expect a secret (named according to this string) for a munge key. This is intended for bursting. Assumed to be at /etc/munge/munge.key This is binary data.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"bursting": {
						SchemaProps: spec.SchemaProps{
							Description: "Bursting - one or more external clusters to burst to We assume a single, central MiniCluster with an ipaddress that all connect to.",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.Bursting"),
						},
					},
					"brokerConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Optionally provide a manually created broker config this is intended for bursting to remote clusters",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./api/v1alpha2/.Bursting", "./api/v1alpha2/.FluxContainer", "./api/v1alpha2/.FluxScheduler"},
	}
}

func schema__api_v1alpha2__LifeCycle(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"postStartExec": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"preStopExec": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
			},
		},
	}
}

func schema__api_v1alpha2__LoggingSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"quiet": {
						SchemaProps: spec.SchemaProps{
							Description: "Quiet mode silences all output so the job only shows the test running",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"strict": {
						SchemaProps: spec.SchemaProps{
							Description: "Strict mode ensures any failure will not continue in the job entrypoint",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"debug": {
						SchemaProps: spec.SchemaProps{
							Description: "Debug mode adds extra verbosity to Flux",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"zeromq": {
						SchemaProps: spec.SchemaProps{
							Description: "Enable Zeromq logging",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"timed": {
						SchemaProps: spec.SchemaProps{
							Description: "Timed mode adds timing to Flux commands",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema__api_v1alpha2__MiniCluster(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MiniCluster is the Schema for a Flux job launcher on K8s",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("./api/v1alpha2/.MiniClusterSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("./api/v1alpha2/.MiniClusterStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./api/v1alpha2/.MiniClusterSpec", "./api/v1alpha2/.MiniClusterStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema__api_v1alpha2__MiniClusterArchive(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Save or load from this directory path",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema__api_v1alpha2__MiniClusterContainer(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"imagePullSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "Allow the user to pull authenticated images By default no secret is selected. Setting this with the name of an already existing imagePullSecret will specify that secret in the pod spec.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Container image must contain flux and flux-sched install",
							Default:     "ghcr.io/rse-ops/accounting:app-latest",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"workingDir": {
						SchemaProps: spec.SchemaProps{
							Description: "Working directory to run command from",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Container name is only required for non flux runners",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"command": {
						SchemaProps: spec.SchemaProps{
							Description: "Single user executable to provide to flux start",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pullAlways": {
						SchemaProps: spec.SchemaProps{
							Description: "Allow the user to dictate pulling By default we pull if not present. Setting this to true will indicate to pull always",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"ports": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Ports to be exposed to other containers in the cluster We take a single list of integers and map to the same",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: 0,
										Type:    []string{"integer"},
										Format:  "int32",
									},
								},
							},
						},
					},
					"environment": {
						SchemaProps: spec.SchemaProps{
							Description: "Key/value pairs for the environment",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"secrets": {
						SchemaProps: spec.SchemaProps{
							Description: "Secrets that will be added to the environment The user is expected to create their own secrets for the operator to find",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("./api/v1alpha2/.Secret"),
									},
								},
							},
						},
					},
					"launcher": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicate that the command is a launcher that will ask for its own jobs (and provided directly to flux start)",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"batch": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicate that the command is a batch job that will be written to a file to submit",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"batchRaw": {
						SchemaProps: spec.SchemaProps{
							Description: "Don't wrap batch commands in flux submit (provide custom logic myself)",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"logs": {
						SchemaProps: spec.SchemaProps{
							Description: "Log output directory",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"runFlux": {
						SchemaProps: spec.SchemaProps{
							Description: "Application container intended to run flux (broker)",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"noWrapEntrypoint": {
						SchemaProps: spec.SchemaProps{
							Description: "Do not wrap the entrypoint to wait for flux, add to path, etc?",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"volumes": {
						SchemaProps: spec.SchemaProps{
							Description: "Existing volumes that can be mounted",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("./api/v1alpha2/.ContainerVolume"),
									},
								},
							},
						},
					},
					"lifeCycle": {
						SchemaProps: spec.SchemaProps{
							Description: "Lifecycle can handle post start commands, etc.",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.LifeCycle"),
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Resources include limits and requests",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.ContainerResources"),
						},
					},
					"commands": {
						SchemaProps: spec.SchemaProps{
							Description: "More specific or detailed commands for just workers/broker",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.Commands"),
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "Security Context https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.SecurityContext"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"./api/v1alpha2/.Commands", "./api/v1alpha2/.ContainerResources", "./api/v1alpha2/.ContainerVolume", "./api/v1alpha2/.LifeCycle", "./api/v1alpha2/.Secret", "./api/v1alpha2/.SecurityContext"},
	}
}

func schema__api_v1alpha2__MiniClusterList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MiniClusterList contains a list of MiniCluster",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("./api/v1alpha2/.MiniCluster"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"./api/v1alpha2/.MiniCluster", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema__api_v1alpha2__MiniClusterSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MiniCluster is an HPC cluster in Kubernetes you can control Either to submit a single job (and go away) or for a persistent single- or multi- user cluster",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Containers is one or more containers to be created in a pod. There should only be one container to run flux with runFlux",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("./api/v1alpha2/.MiniClusterContainer"),
									},
								},
							},
						},
					},
					"services": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Services are one or more service containers to bring up alongside the MiniCluster.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("./api/v1alpha2/.MiniClusterContainer"),
									},
								},
							},
						},
					},
					"network": {
						SchemaProps: spec.SchemaProps{
							Description: "A spec for exposing or defining the cluster headless service",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.Network"),
						},
					},
					"jobLabels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels for the job",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"interactive": {
						SchemaProps: spec.SchemaProps{
							Description: "Run a single-user, interactive minicluster",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"flux": {
						SchemaProps: spec.SchemaProps{
							Description: "Flux options for the broker, shared across cluster",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.FluxSpec"),
						},
					},
					"logging": {
						SchemaProps: spec.SchemaProps{
							Description: "Logging modes determine the output you see in the job log",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.LoggingSpec"),
						},
					},
					"archive": {
						SchemaProps: spec.SchemaProps{
							Description: "Archive to load or save",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.MiniClusterArchive"),
						},
					},
					"shareProcessNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Share process namespace?",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"suspendWorkers": {
						SchemaProps: spec.SchemaProps{
							Description: "Restart failed workers (defaults to true) This is setting backoffLimitPerIndex to 0 on the backend This requires an additional feature gate to be enabled.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"cleanup": {
						SchemaProps: spec.SchemaProps{
							Description: "Cleanup the pods and storage when the index broker pod is complete",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"size": {
						SchemaProps: spec.SchemaProps{
							Description: "Size (number of job pods to run, size of minicluster in pods) This is also the minimum number required to start Flux",
							Default:     1,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxSize": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxSize (maximum number of pods to allow scaling to)",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"tasks": {
						SchemaProps: spec.SchemaProps{
							Description: "Total number of CPUs being run across entire cluster",
							Default:     1,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"deadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Should the job be limited to a particular number of seconds? Approximately one year. This cannot be zero or job won't start",
							Default:     3.15e+07,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"pod": {
						SchemaProps: spec.SchemaProps{
							Description: "Pod spec details",
							Default:     map[string]interface{}{},
							Ref:         ref("./api/v1alpha2/.PodSpec"),
						},
					},
				},
				Required: []string{"containers"},
			},
		},
		Dependencies: []string{
			"./api/v1alpha2/.FluxSpec", "./api/v1alpha2/.LoggingSpec", "./api/v1alpha2/.MiniClusterArchive", "./api/v1alpha2/.MiniClusterContainer", "./api/v1alpha2/.Network", "./api/v1alpha2/.PodSpec"},
	}
}

func schema__api_v1alpha2__MiniClusterStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MiniClusterStatus defines the observed state of Flux",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"size": {
						SchemaProps: spec.SchemaProps{
							Description: "These are for the sub-resource scale functionality",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"jobid": {
						SchemaProps: spec.SchemaProps{
							Description: "The Jobid is set internally to associate to a miniCluster This isn't currently in use, we only have one!",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"maximumSize": {
						SchemaProps: spec.SchemaProps{
							Description: "We keep the original size of the MiniCluster request as this is the absolute maximum",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "conditions hold the latest Flux Job and MiniCluster states",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.Condition"),
									},
								},
							},
						},
					},
				},
				Required: []string{"size", "selector", "jobid", "maximumSize"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Condition"},
	}
}

func schema__api_v1alpha2__MiniClusterUser(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "If a user is defined, the username is required",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"password": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
				Required: []string{"name"},
			},
		},
	}
}

func schema__api_v1alpha2__Network(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"headlessName": {
						SchemaProps: spec.SchemaProps{
							Description: "Name for cluster headless service",
							Default:     "flux-service",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"disableAffinity": {
						SchemaProps: spec.SchemaProps{
							Description: "Disable affinity rules that guarantee one network address / node",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema__api_v1alpha2__PodSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodSpec controlls variables for the cluster pod",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations for each pod",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels for each pod",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "Service account name for the pod",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "Scheduler name for the pod",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelectors for a pod",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Resources include limits and requests",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema__api_v1alpha2__Secret(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Secret describes a secret from the environment. The envar name should be the key of the top level map.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name under secretKeyRef->Name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"key": {
						SchemaProps: spec.SchemaProps{
							Description: "Key under secretKeyRef->Key",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"name", "key"},
			},
		},
	}
}

func schema__api_v1alpha2__SecurityContext(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"privileged": {
						SchemaProps: spec.SchemaProps{
							Description: "Privileged container",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"addCapabilities": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Capabilities to add",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}
